#include <iostream>
#include <cstring>
#include <cstdlib>

struct Victim {
    char data[16];

    void print_data() {
        std::cout << "[*] Victim::data = " << data << "\n";
    }
};

int main() {
    std::cout << "[+] Allocating Victim...\n";
    Victim* victim = new Victim();
    printf("victim at:   %p\n", victim);
    strcpy(victim->data, "SafeData");
    victim->print_data();

    std::cout << "[+] Deleting Victim...\n";
    delete victim; // victim is now a dangling pointer

    // Heap grooming: Allocate attacker-controlled data over the same chunk
    std::cout << "[+] Attacker allocating same-sized chunk...\n";
    char* attacker_data = new char[sizeof(Victim)];
    printf("attacker_data:  %p\n", attacker_data);
    strcpy(attacker_data, "Pwned!!!");

    // UAF: Use victim pointer after free
    std::cout << "[*] Using victim after free:\n";
    victim->print_data(); // should print "Pwned!!!" if memory was reused

    // Cleanup
    delete[] attacker_data;
    return 0;
}
